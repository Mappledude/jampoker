<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Table</title>
  <link rel="stylesheet" href="/style.css" />
  <link rel="stylesheet" href="/table.css" />
</head>
<body>
  <div class="wrap">
    <nav class="nav">
      <span style="font-weight:700;">JamPoker</span>
      <a href="/lobby.html">Lobby</a>
      <button id="chat-toggle" class="toolbar-btn" aria-pressed="false" style="margin-left:auto;margin-right:8px;">Chat</button>
      <button id="export-debug-btn" class="toolbar-btn" type="button" style="margin-right:8px;">Export Debug</button>
      <span id="debug-chip" class="small" style="cursor:pointer;padding:4px 8px;border:1px solid #334155;border-radius:8px;">Debug: OFF</span>
    </nav>
    <div id="you"></div>
    <div id="error" class="card" style="display:none;"></div>
    <div id="table-info" class="card" style="margin-top:16px;"></div>
    <div id="current-hand" class="card" style="margin-top:16px;"></div>
    <div id="seats" class="card" style="margin-top:16px;"></div>
  </div>
  <aside id="chat-panel" class="chat-panel card" style="position:fixed;right:16px;bottom:16px;"></aside>
  <div id="player-board" class="card player-board" style="display:none;position:fixed;left:50%;bottom:0;transform:translateX(-50%);min-width:260px;"></div>
  <div id="debug-box" class="dbg" style="display:none;font-family:monospace;white-space:pre;font-size:11px;margin-top:12px;"></div>
  <div id="debug-export-modal" style="display:none;position:fixed;inset:0;background:rgba(15,23,42,0.85);z-index:10000;align-items:center;justify-content:center;padding:24px;box-sizing:border-box;">
    <div style="background:#0f172a;border:1px solid #1e293b;border-radius:12px;max-width:720px;width:100%;max-height:90vh;display:flex;flex-direction:column;box-shadow:0 20px 60px rgba(15,23,42,0.6);">
      <div style="display:flex;align-items:center;justify-content:space-between;padding:16px 20px;border-bottom:1px solid #1e293b;gap:12px;flex-wrap:wrap;">
        <h2 style="margin:0;font-size:18px;">Export Debug Packet</h2>
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin-left:auto;">
          <label class="small" style="display:flex;align-items:center;gap:6px;">
            <input id="debug-export-raw" type="checkbox" />
            <span>Include noop events</span>
          </label>
          <button id="debug-export-copy" type="button" style="padding:6px 12px;border-radius:8px;border:1px solid #334155;background:#0ea5e9;color:white;font-weight:600;cursor:pointer;">Copy</button>
          <button id="debug-export-close" type="button" style="padding:6px 12px;border-radius:8px;border:1px solid #334155;background:#1e293b;color:#e2e8f0;cursor:pointer;">Close</button>
        </div>
      </div>
      <div style="padding:12px 20px;">
        <p id="debug-export-status" class="small" style="margin:0 0 8px 0;color:#cbd5f5;"></p>
        <textarea id="debug-export-text" readonly style="width:100%;min-height:320px;max-height:55vh;background:#020617;color:#e2e8f0;border:1px solid #1e293b;border-radius:10px;padding:12px;font-family:monospace;font-size:12px;line-height:1.4;box-sizing:border-box;resize:vertical;"></textarea>
      </div>
    </div>
  </div>
  <script src="/jamlog.js"></script>
  <script type="module" src="/firebase-init.js"></script>
  <script type="module">
    import { app } from "/firebase-init.js";
    import { startActionWorker } from "/adminWorker.js";
    import { initAdminHud } from "/js/adminHud.js";
    import { startHand } from "/startHand.js";
    import { db, dollars, formatCents, renderCurrentPlayerControls, isDebug, setDebug, getCurrentPlayer, formatCard, stageLabel, showSeatsDebug, debugLog } from "/common.js";
    import {
      doc, setDoc, updateDoc, onSnapshot, collection, query, orderBy, serverTimestamp,
      writeBatch, runTransaction, increment, getDoc, addDoc
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
    import { awaitAuthReady, auth } from "/auth.js";
      import { handDocPath } from "/js/dbPaths.js";
      import { logEvent } from "/js/debug.js";

      const shortUid = (uid) => uid ? uid.slice(0, 6) : 'null';

      const toSeatNumber = (v) => {
        if (typeof v === 'number' && Number.isInteger(v)) return v;
        if (typeof v === 'string' && /^\d+$/.test(v)) return Number(v);
        return null;
      };

      const toCents = (value) => {
        if (typeof value === 'number') return Number.isFinite(value) ? value : null;
        const num = Number(value);
        return Number.isFinite(num) ? num : null;
      };

      const toHandNumber = (value) => {
        if (typeof value === 'number' && Number.isInteger(value)) return value;
        if (typeof value === 'string' && /^\d+$/.test(value)) return Number(value);
        return null;
      };

      const buildHandStatePayload = (state) => {
        const safe = state || {};
        const rawCommits = safe.commits && typeof safe.commits === 'object' ? safe.commits : null;
        const commitKeys = rawCommits ? Object.keys(rawCommits).sort((a, b) => Number(a) - Number(b)) : [];
        const commits = {};
        commitKeys.forEach((key) => {
          const cents = toCents(rawCommits[key]);
          if (cents !== null) commits[key] = cents;
        });
        const commitValues = Object.values(commits);
        const potFromCommits = commitValues.reduce((sum, value) => sum + (Number.isFinite(value) ? value : 0), 0);
        const betToMatchCents = toCents(safe.betToMatchCents);
        let potCents = toCents(safe.potCents);
        if (potCents === null && commitValues.length > 0) potCents = potFromCommits;
        return {
          handNo: toHandNumber(safe.handNo ?? null),
          street: safe.street ?? null,
          toActSeat: toSeatNumber(safe.toActSeat ?? null),
          betToMatchCents: betToMatchCents ?? null,
          potCents: potCents ?? null,
          commits: commitValues.length > 0 ? commits : {},
          lastAggressorSeat: toSeatNumber(safe.lastAggressorSeat ?? null),
          lastRaiseSizeCents: toCents(safe.lastRaiseSizeCents ?? null),
          lastRaiseToCents: toCents(safe.lastRaiseToCents ?? null),
        };
      };

      const deriveHandContext = (snapshot) => {
        const base = snapshot || {};
        const commits = base.commits && typeof base.commits === 'object' ? base.commits : {};
        const current = getCurrentPlayer();
        const seatEntry = current ? seatData.find((s) => s.occupiedBy === current.id) : null;
        const mySeat = toSeatNumber(seatEntry?.seatIndex ?? null);
        let myCommit = null;
        if (mySeat !== null && Object.prototype.hasOwnProperty.call(commits, String(mySeat))) {
          const commitValue = commits[String(mySeat)];
          const cents = toCents(commitValue);
          if (cents !== null) myCommit = cents;
        }
        let potCents = base.potCents ?? null;
        if ((potCents === null || !Number.isFinite(potCents)) && commits) {
          const values = Object.values(commits);
          if (values.length > 0) {
            potCents = values.reduce((sum, value) => sum + (Number.isFinite(value) ? value : 0), 0);
          }
        }
        return {
          toMatch: base.betToMatchCents ?? null,
          myCommit: myCommit ?? null,
          potCents: potCents ?? null,
          mySeat,
          toActSeat: base.toActSeat ?? null,
          street: base.street ?? null,
          handNo: base.handNo ?? null,
        };
      };

      const JAMLOG_THROTTLE_MS = 500;
      const JAMLOG_THROTTLE_KEYS = ['toActSeat', 'street', 'handNo', 'toMatch', 'myCommit'];
      const jamlogThrottleState = {};
      const jamlogThrottleTargets = new Set(['turn.snapshot', 'action.guard']);
      const jamlogPushThrottled = (event, payload, meta = {}) => {
        if (!window.jamlog || typeof window.jamlog.push !== 'function') return;
        if (!jamlogThrottleTargets.has(event)) {
          window.jamlog.push(event, payload);
          return;
        }
        const now = Date.now();
        const state = jamlogThrottleState[event] || { lastAt: 0, lastSignature: null };
        const relevant = {};
        JAMLOG_THROTTLE_KEYS.forEach((key) => {
          const value = meta && Object.prototype.hasOwnProperty.call(meta, key) ? meta[key] : undefined;
          relevant[key] = value === undefined ? null : value;
        });
        const signature = JSON.stringify(relevant);
        const first = state.lastSignature === null;
        const changed = signature !== state.lastSignature;
        const elapsed = now - state.lastAt;
        const reasonValue = typeof meta.reason === 'string' ? meta.reason : null;
        const reasonNonOk = reasonValue !== null && reasonValue !== 'ok';
        if (!(first || elapsed >= JAMLOG_THROTTLE_MS || changed || reasonNonOk)) return;
        jamlogThrottleState[event] = { lastAt: now, lastSignature: signature };
        window.jamlog.push(event, payload);
      };

    if (window.jamlog) {
      window.jamlog.init({ projectId: app.options.projectId, build: window.__BUILD_SHA__ || 'dev', page: 'TABLE' });
    }

    renderCurrentPlayerControls("you");
    const debugChip = document.getElementById('debug-chip');
    debugChip.textContent = isDebug() ? 'Debug: ON' : 'Debug: OFF';
    debugChip.addEventListener('click', () => setDebug(!isDebug()));
    const chatToggle = document.getElementById('chat-toggle');
    const chatPanel = document.getElementById('chat-panel');
    let chatOpen = false;
    chatToggle.addEventListener('click', () => {
      chatOpen = !chatOpen;
      chatToggle.setAttribute('aria-pressed', chatOpen ? 'true' : 'false');
      chatPanel.classList.toggle('open', chatOpen);
    });

    const exportBtn = document.getElementById('export-debug-btn');
    const exportModal = document.getElementById('debug-export-modal');
    const exportTextarea = document.getElementById('debug-export-text');
    const exportCopyBtn = document.getElementById('debug-export-copy');
    const exportCloseBtn = document.getElementById('debug-export-close');
    const exportStatus = document.getElementById('debug-export-status');
    const exportRawToggle = document.getElementById('debug-export-raw');
    let exportGeneration = 0;
    let tableHud = null;
    let tableWorkerUnsub = null;

    const closeExportModal = () => {
      if (exportModal) exportModal.style.display = 'none';
      exportGeneration += 1;
    };

    const logPacketMarkers = (packet) => {
      if (!packet) return;
      packet.split('\n').forEach((line) => {
        if (line.startsWith('=== JAMPOKER DEBUG PACKET v2 BEGIN')) console.log(line);
        if (line === '=== JAMPOKER DEBUG PACKET v2 END ===') console.log(line);
      });
    };

    const renderExportPacket = async () => {
      if (!exportStatus || !exportTextarea) return;
      if (!window.jamlog || typeof window.jamlog.export !== 'function') {
        exportStatus.textContent = 'jamlog unavailable on this page.';
        exportTextarea.value = '';
        return;
      }
      const raw = !!(exportRawToggle && exportRawToggle.checked);
      const requestId = ++exportGeneration;
      exportStatus.textContent = raw ? 'Generating packet (raw)…' : 'Generating packet…';
      exportTextarea.value = '';
      try {
        const packet = await window.jamlog.export({ raw });
        if (requestId !== exportGeneration) return;
        exportTextarea.value = packet;
        exportStatus.textContent = `Size: ${packet.length.toLocaleString()} chars${raw ? ' (raw)' : ''}`;
        logPacketMarkers(packet);
      } catch (err) {
        if (requestId !== exportGeneration) return;
        console.error('Failed to export debug packet', err);
        exportStatus.textContent = 'Export failed. Check console for details.';
      }
    };

    if (exportBtn && exportModal) {
      exportBtn.addEventListener('click', () => {
        exportModal.style.display = 'flex';
        exportModal.setAttribute('role', 'dialog');
        exportModal.setAttribute('aria-modal', 'true');
        renderExportPacket();
      });
    }

    if (exportRawToggle) {
      exportRawToggle.addEventListener('change', () => {
        renderExportPacket();
      });
    }

    if (exportCopyBtn && exportTextarea) {
      exportCopyBtn.addEventListener('click', async () => {
        try {
          await navigator.clipboard.writeText(exportTextarea.value);
          exportCopyBtn.textContent = 'Copied!';
          setTimeout(() => { exportCopyBtn.textContent = 'Copy'; }, 1500);
        } catch (err) {
          console.error('Failed to copy debug packet', err);
          exportCopyBtn.textContent = 'Copy failed';
          setTimeout(() => { exportCopyBtn.textContent = 'Copy'; }, 1500);
        }
      });
    }

    if (exportCloseBtn) {
      exportCloseBtn.addEventListener('click', () => {
        closeExportModal();
      });
    }

    if (exportModal) {
      exportModal.addEventListener('click', (event) => {
        if (event.target === exportModal) closeExportModal();
      });
    }

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape' && exportModal && exportModal.style.display === 'flex') {
        closeExportModal();
      }
    });

    const params = new URLSearchParams(window.location.search);
    const tableId = params.get('id');
    const controlsRoot = document.getElementById('table-controls') || document;
    controlsRoot.addEventListener('click', async (e) => {
      const btn = e.target.closest('[data-action="start-hand"]');
      if (!btn) return;
      if (btn.disabled) return;
      btn.disabled = true;
      try {
        await startHand(tableId);
        // keep disabled until hand.state subscription confirms presence
      } catch (err) {
        console.error('startHand failed', err);
        btn.disabled = false;
      }
    });
    await awaitAuthReady();
    const u = auth.currentUser;
    if (u && tableId) {
      const tSnap = await getDoc(doc(db, `tables/${tableId}`));
      const createdByUid = tSnap.exists() ? (tSnap.data()?.createdByUid || null) : null;
      const isAdmin = !!(createdByUid && createdByUid === u.uid);
      if (isAdmin) {
        document.body.classList.add('is-table-admin');
        const tableSnapData = tSnap.exists() ? (tSnap.data() || null) : null;
        const tableName = tableSnapData && typeof tableSnapData.name === 'string' ? tableSnapData.name : null;
        tableHud = initAdminHud({
          page: 'TABLE',
          jamlog: window.jamlog,
          startWorker: (tid) => {
            if (!tid || tid !== tableId) return false;
            if (tableWorkerUnsub) return false;
            tableWorkerUnsub = startActionWorker(tid);
            return true;
          },
          stopWorker: (tid) => {
            if (!tid || tid !== tableId) return false;
            if (!tableWorkerUnsub) return false;
            tableWorkerUnsub();
            tableWorkerUnsub = null;
            return true;
          },
          getWorkerState: (tid) => !!tableWorkerUnsub && tid === tableId,
        });
        tableHud.setContext({ tableId, isOwner: true, tableName, autoStart: true });
        window.addEventListener('beforeunload', () => {
          try {
            tableHud?.destroy?.();
          } catch (err) {
            console.warn('tableHud.destroy failed', err);
          }
          tableHud = null;
          if (tableWorkerUnsub) {
            tableWorkerUnsub();
            tableWorkerUnsub = null;
          }
        }, { once: true });
        try {
          const { initAdvanceStreet } = await import('/js/advanceStreet.js');
          initAdvanceStreet({ tableId });
        } catch (err) {
          console.error('Failed to load advance street controls', err);
          logEvent('ui.advanceStreet.load.fail', { tableId, message: err?.message });
          if (window.jamlog) window.jamlog.push('ui.advanceStreet.load.fail', { tableId, message: err?.message });
        }
      } else {
        if (window.jamlog) window.jamlog.push('worker.skip', { tableId, isAdmin: false });
      }
    }
    document.body.classList.add('variant-v1');
    if (window.jamlog) window.jamlog.setTableId(tableId || null);
    const errorEl = document.getElementById('error');
    const infoEl = document.getElementById('table-info');
    const handEl = document.getElementById('current-hand');
    const seatsEl = document.getElementById('seats');
    const boardEl = document.getElementById('player-board');
    const debugBox = document.getElementById('debug-box');
    const seedBanner = document.createElement('div');
    seedBanner.className = 'small';
    seedBanner.textContent = 'Seeding seats…';
    seedBanner.style.display = 'none';
    seatsEl.before(seedBanner);
    const noHandBanner = document.createElement('div');
    noHandBanner.className = 'small';
    noHandBanner.textContent = 'No hand in progress. Start Hand.';
    noHandBanner.style.display = 'none';
    seatsEl.before(noHandBanner);

    let tableData = null;
    let handData = null;
    let handState = null;
    let seatData = [];
    let mySeatIndex = null;
    const foldedSeats = new Set();
    let pending = null;
    let pendingTimer = null;
    let unsubHand = null;
    let unsubHandState = null;
    let backfillAttempted = false;
    let backfillTimer = null;
    let seatCountTimer = null;
    let seatCountDesync = false;
    let lastHandStateLogKey = null;
    const tableRef = tableId ? doc(db, 'tables', tableId) : null;
    const handRef = tableId ? doc(db, handDocPath(tableId)) : null;

    function pushHandStateChanged(state) {
      const payload = buildHandStatePayload(state);
      const derived = deriveHandContext(payload);
      if (window.jamlog) {
        window.jamlog.hand = {
          snapshot: { ...payload, commits: { ...payload.commits } },
          derived: { ...derived },
        };
      }
      const key = JSON.stringify(payload);
      if (lastHandStateLogKey === key) return payload;
      lastHandStateLogKey = key;
      if (window.jamlog) window.jamlog.push('hand.state.changed', payload);
      return payload;
    }

    function subscribeHandState(tableId, onChange) {
      const path = handDocPath(tableId);
      const ref = doc(db, path);
      logEvent('hand.state.sub.path', { path });
      return onSnapshot(ref, (snap) => {
        if (!snap.exists()) return onChange(null);
        onChange(snap.data());
      }, (err) => {
        if (window.jamlog) window.jamlog.push('hand.state.sub.error', { code: err?.code, message: err?.message });
      });
    }

    if (!tableId) {
      errorEl.style.display = 'block';
      errorEl.innerHTML = '<h1>Table not found</h1><a href="/lobby.html">Back to Lobby</a>';
    } else {
      if (window.jamlog) window.jamlog.push('hand.state.sub.start');
        unsubHandState = subscribeHandState(tableId, (data) => {
          if (data) {
            handState = data;
            handState.toActSeat = toSeatNumber(handState?.toActSeat);
            handState.sbSeat = toSeatNumber(handState?.sbSeat);
            handState.bbSeat = toSeatNumber(handState?.bbSeat);
            handState.dealerSeat = toSeatNumber(handState?.dealerSeat);
            const handSnapshotPayload = pushHandStateChanged(handState);
            noHandBanner.style.display = 'none';
            if (pending) {
              pending = null;
              if (pendingTimer) clearTimeout(pendingTimer);
            }
            renderSeats();
            renderPlayerBoard();
            if (window.jamlog) {
              window.jamlog.push('hand.state.sub.ok', {
                ...handSnapshotPayload,
                commits: { ...handSnapshotPayload.commits },
              });
            }
          } else {
            handState = null;
            pushHandStateChanged(null);
            if (pending) {
              pending = null;
              if (pendingTimer) clearTimeout(pendingTimer);
            }
            renderSeats();
            renderPlayerBoard();
            noHandBanner.style.display = '';
            if (window.jamlog) window.jamlog.push('hand.state.sub.empty');
          }
        });
      onSnapshot(tableRef, (snap) => {
        debugLog('table.tableSnapshot', snap.exists());
        if (!snap.exists() || snap.data()?.active === false) {
          errorEl.style.display = 'block';
          const msg = !snap.exists() ? 'Table not found' : 'Table archived';
          errorEl.innerHTML = `<h1>${msg}</h1><a href="/lobby.html">Back to Lobby</a>`;
          infoEl.style.display = 'none';
          handEl.style.display = 'none';
          seatsEl.style.display = 'none';
          boardEl.style.display = 'none';
          return;
        }
        infoEl.style.display = '';
        handEl.style.display = '';
        seatsEl.style.display = '';
        tableData = { id: snap.id, ...snap.data() };
        renderTableInfo();
        if (unsubHand) unsubHand();
        if (tableData.currentHandId) {
          const handRef = doc(db, 'tables', tableId, 'hands', tableData.currentHandId);
          unsubHand = onSnapshot(handRef, (hsnap) => {
            handData = hsnap.exists() ? hsnap.data() : null;
            renderHand();
            updateDebug();
          });
        } else {
          handData = null;
          renderHand();
          updateDebug();
        }
          renderPlayerBoard();
          updateDebug();
          checkSeatCount();
        });

        const seatsRef = collection(db, 'tables', tableId, 'seats');
        if (window.jamlog) window.jamlog.push('table.seats.sub.started');
        const qSeats = query(seatsRef, orderBy('seatIndex', 'asc'));
          onSnapshot(qSeats, (snap) => {
            debugLog('table.seatsSnapshot', snap.size);
            if (window.jamlog) window.jamlog.push('table.seats.sub.ok', { count: snap.size });
            seatData = snap.docs.map((d) => {
              const data = d.data();
              const seatIndex = toSeatNumber(data?.seatIndex ?? d.id);
              return { id: d.id, ...data, seatIndex };
            });
            showSeatsDebug(tableId, snap.docs);
            renderSeats();
            renderHand();
            renderTableInfo();
            renderPlayerBoard();
          updateDebug();
          checkSeatCount();
          if (snap.size === 0 && (tableData?.maxSeats || 0) > 0) {
            if (!backfillTimer && !backfillAttempted) {
              backfillTimer = setTimeout(() => {
                backfillTimer = null;
                if (seatData.length === 0 && (tableData?.maxSeats || 0) > 0) backfillSeats();
              }, 1000);
            }
          } else if (backfillTimer) {
            clearTimeout(backfillTimer);
            backfillTimer = null;
          }
        }, (err) => {
          if (window.jamlog) window.jamlog.push('table.seats.sub.error', { code: err?.code, message: err?.message });
        });
      }

    document.addEventListener('change', (e) => {
      if (e.target.id === 'cp-select') renderPlayerBoard();
    });

    async function backfillSeats() {
      backfillAttempted = true;
      if (isDebug()) seedBanner.style.display = 'block';
      try {
        const batch = writeBatch(db);
        const max = tableData.maxSeats || 0;
        const checks = [];
        for (let i = 0; i < max; i++) {
          const sref = doc(db, 'tables', tableId, 'seats', String(i));
          checks.push(getDoc(sref).then((snap) => {
            if (!snap.exists()) {
              batch.set(sref, {
                seatIndex: i,
                occupiedBy: null,
                displayName: null,
                sittingOut: false,
                stackCents: null,
                updatedAt: serverTimestamp(),
              });
            }
          }));
        }
        await Promise.all(checks);
        await batch.commit();
        if (window.jamlog) window.jamlog.push('table.seats.backfill.ok', { count: max });
      } catch (e) {
        if (window.jamlog) window.jamlog.push('table.seats.backfill.fail', { code: e?.code });
      } finally {
        if (isDebug()) seedBanner.style.display = 'none';
      }
    }

    function checkSeatCount() {
      if (!tableData) return;
      const derived = seatData.filter(s => s.occupiedBy).length;
      const active = tableData.activeSeatCount ?? 0;
      if (derived !== active) {
        if (!seatCountTimer) {
          seatCountTimer = setTimeout(() => {
            seatCountTimer = null;
            const d = seatData.filter(s => s.occupiedBy).length;
            const a = tableData.activeSeatCount ?? 0;
            if (d !== a) {
              seatCountDesync = true;
              if (window.jamlog) window.jamlog.push('seatcount.desync', { derived: d, activeSeatCount: a });
              renderTableInfo();
            }
          }, 1000);
        }
      } else {
        if (seatCountTimer) { clearTimeout(seatCountTimer); seatCountTimer = null; }
        if (seatCountDesync) {
          seatCountDesync = false;
          renderTableInfo();
        }
      }
    }

    async function renderTableInfo() {
      if (!tableData) { infoEl.textContent = ''; return; }
      const t = tableData;
      const sb = t?.blinds?.sbCents ?? t.smallBlindCents ?? 0;
      const bb = t?.blinds?.bbCents ?? t.bigBlindCents ?? 0;
      const minB = t?.buyIn?.minCents ?? t.minBuyInCents ?? 0;
      const maxB = t?.buyIn?.maxCents ?? t.maxBuyInCents ?? 0;
      const defB = t?.buyIn?.defaultCents ?? t.defaultBuyInCents ?? 0;
      const blindStr = `${dollars(sb)}/${dollars(bb)}`;
      const rangeStr = `${dollars(minB)}–${dollars(maxB)} (default ${dollars(defB)})`;
      const derivedSeatCount = seatData.filter(s => s.occupiedBy).length;
      const activeSeatCount = t.activeSeatCount ?? 0;
      const desyncLine = seatCountDesync ? `<div class="small">Players seated: ${derivedSeatCount} (active: ${activeSeatCount})</div>` : '';
      const probeBtnHtml = isDebug() ? `<button id="btn-rules-probe" class="small" style="margin-left:8px;">Rules Probe</button>` : '';
      const startBtnHtml = `<div id="start-hand-wrap" style="margin-top:8px;text-align:right;"><button id="btn-start-hand" class="small" data-action="start-hand">Start Hand</button>${probeBtnHtml}<div id="start-hand-hint" class="small" style="margin-top:4px;display:none;"></div></div>`;
      infoEl.innerHTML = `
        <h1>${t.name || '(no name)'}</h1>
        <div class="small">Blinds: ${blindStr}</div>
        <div class="small">Buy-in: ${rangeStr}</div>
        <div class="small">Seats: ${derivedSeatCount} / ${t.maxSeats || 0}</div>
        ${desyncLine}
        ${startBtnHtml}
      `;
      document.getElementById('btn-rules-probe')?.addEventListener('click', () => rulesProbe(tableId));
        const startBtn = document.getElementById('btn-start-hand');
        const hintEl = document.getElementById('start-hand-hint');
        startBtn.disabled = true;
        let enable = false;
        await awaitAuthReady();
        const uid = auth.currentUser?.uid || null;
      if (!t.createdByUid || (uid && t.createdByUid === uid)) {
        if (derivedSeatCount >= 2) {
          enable = true;
        } else {
          startBtn.title = 'Need 2+ players';
        }
        } else {
          const msg = `Only the table owner can start a hand. Owner: ${shortUid(t.createdByUid)}`;
          startBtn.title = msg;
          hintEl.textContent = msg;
          hintEl.style.display = '';
          if (window.jamlog) window.jamlog.push('hand.start.disabled', { reason: 'not-admin' });
        }
        const handActive = !!handData && typeof handData.handNo === 'number' && handData.street;
        startBtn.disabled = handActive || !enable;
        if (!startBtn.disabled) {
          startBtn.removeAttribute('title');
        } else if (handActive) {
          startBtn.title = 'Hand already in progress';
        }
      }

    function renderHand() {
      if (!handData) {
        const seatCount = seatData.filter(s => s.occupiedBy).length;
        handEl.innerHTML = seatCount < 2 ? 'Waiting for players…' : 'Waiting for next dealer’s choice…';
        renderPlayerBoard();
        return;
      }
      if (handData.status === 'ended') {
        handEl.textContent = handData.showdownPending ? 'Showdown pending — pot held' : 'Hand ended — waiting for next hand…';
        renderPlayerBoard();
        return;
      }
      const h = handData;
      const vLabel = h.variant === 'omaha' ? 'Omaha' : "Hold'em";
      const stageStr = stageLabel(h);
      const getNameBySeat = (n) => seatData.find(s => s.seatIndex === n)?.displayName || '(left)';
      const dealerName = h.dealerName || getNameBySeat(h.positions?.dealerSeatNum);
      const sbName = getNameBySeat(h.positions?.sbSeatNum);
      const bbName = getNameBySeat(h.positions?.bbSeatNum);
      const actorName = getNameBySeat(h.actorSeatNum);
      const board = (h.board || []).map(c => `<span class="card-chip">${formatCard(c)}</span>`).join(' ');
      const commits = h.commits || {};
      const derivedPot = Object.values(commits).reduce((a, b) => a + (b || 0), 0);
      const potCents = typeof h.potCents === 'number' ? h.potCents : derivedPot;
      let contrib = '';
      if (h.contributions) {
        const parts = [];
        for (const [pid, cents] of Object.entries(h.contributions)) {
          const name = seatData.find(s => s.occupiedBy === pid)?.displayName || '(left)';
          parts.push(`${name}: ${dollars(cents)}`);
        }
        if (parts.length) contrib = `<div class="small">${parts.join(', ')}</div>`;
      }
      const boardLine = (h.board && h.board.length)
        ? `<div class="small">Board: ${board}</div>`
        : '';
      const debugLine = isDebug()
        ? `<div class="small">board=${(h.board||[]).join(',')}${h.deckIndex !== undefined ? ` deckIndex=${h.deckIndex}` : ''}</div>`
        : '';
      handEl.innerHTML = `
        <div>Current Hand: ${vLabel} • Dealer: ${dealerName} • Status: ${h.status}</div>
        <div class="small" style="margin-top:4px;">Pot: ${dollars(potCents)}</div>
        <div class="small">Stage: ${stageStr}</div>
        ${boardLine}
        <div class="small">Positions: Dealer ${dealerName}, SB ${sbName}, BB ${bbName}</div>
        ${contrib}
        <div class="small" style="margin-top:4px;">Action: ${actorName}</div>
        ${debugLine}
      `;
      renderPlayerBoard();
    }

    function renderSeats() {
      const maxSeats = tableData?.maxSeats || seatData.length || 0;
      const ring = document.createElement('div');
      ring.className = 'seat-ring';
      for (let i = 0; i < maxSeats; i++) {
        const seat = seatData.find((s) => s.seatIndex === i);
        const seatEl = document.createElement('div');
        seatEl.className = 'seat';
        seatEl.style.setProperty('--i', String(i));
        seatEl.style.setProperty('--n', String(maxSeats));
        if (seat && seat.occupiedBy) {
          const stackLabel = seat.stackCents != null ? formatCents(seat.stackCents) : '—';
          seatEl.innerHTML = `<div class="name">${seat.displayName || '(no name)'}</div><div class="stack small">${stackLabel}</div>`;
        } else {
          seatEl.innerHTML = '<div class="small">Sit here</div>';
          seatEl.addEventListener('click', () => claimSeat(i));
        }
        if (handState) {
          if (i === handState.dealerSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge dealer';
            b.textContent = 'D';
            seatEl.appendChild(b);
          }
          if (i === handState.sbSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge sb';
            b.textContent = 'SB';
            seatEl.appendChild(b);
          }
          if (i === handState.bbSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge bb';
            b.textContent = 'BB';
            seatEl.appendChild(b);
          }
        }
        ring.appendChild(seatEl);
      }
      seatsEl.innerHTML = '';
      seatsEl.appendChild(ring);
    }

    async function claimSeat(seatIndex) {
      const current = getCurrentPlayer();
      if (!current) { alert('Select a Current Player first.'); return; }
      if (window.jamlog) window.jamlog.push('seat.tx.start', { seatIndex });
      let stack = 0;
      let phase = 'seatWrite';
      try {
        await awaitAuthReady();
        await runTransaction(db, async (tx) => {
          const tableRef = doc(db, 'tables', tableId);
          const seatRef = doc(db, 'tables', tableId, 'seats', String(seatIndex));
          const [tableSnap, seatSnap] = await Promise.all([
            tx.get(tableRef),
            tx.get(seatRef),
          ]);
          if (!tableSnap.exists()) throw new Error('Table not found');
          if (seatSnap.exists() && seatSnap.data()?.occupiedBy) throw new Error('Seat taken');
          const t = tableSnap.data();
          const buy = t?.buyIn || {};
          let min = typeof buy.minCents === 'number' ? buy.minCents : 0;
          let max = typeof buy.maxCents === 'number' ? buy.maxCents : min;
          let def = typeof buy.defaultCents === 'number' ? buy.defaultCents : min;
          if (min > max) {
            if (window.jamlog) window.jamlog.push('table.buyin.invalid', { minCents: min, maxCents: max });
            const fb = Math.min(min, max);
            min = max = def = fb;
          }
          stack = Math.min(Math.max(def, min), max);
          const seatData = {
            seatIndex,
            occupiedBy: current.id,
            displayName: current.name || '',
            sittingOut: false,
            stackCents: stack,
            updatedAt: serverTimestamp(),
          };
          if (seatSnap.exists()) tx.update(seatRef, seatData);
          else tx.set(seatRef, seatData);
          phase = 'tableUpdate';
          tx.update(tableRef, { activeSeatCount: increment(1) });
        });
        if (window.jamlog) {
          window.jamlog.push('seat.tx.ok', { seatIndex });
          window.jamlog.push('seat.tx.claim.stack', { seatIndex, stackCents: stack });
        }
      } catch (err) {
        if (window.jamlog) {
          if (phase === 'tableUpdate') window.jamlog.push('seat.tx.fail.tableUpdate', { code: err?.code });
          else window.jamlog.push('seat.tx.fail.seatWrite', { code: err?.code });
          window.jamlog.push('seat.tx.fail', { seatIndex, code: err?.code, message: err?.message });
        }
        alert('Seat taken or no permission.');
      }
    }

    async function leaveSeat(seatIndex) {
      const current = getCurrentPlayer();
      if (!current) return;
      if (window.jamlog) window.jamlog.push('seat.tx.start', { seatIndex });
      let phase = 'seatWrite';
      try {
        await awaitAuthReady();
        await runTransaction(db, async (tx) => {
          const tableRef = doc(db, 'tables', tableId);
          const seatRef = doc(db, 'tables', tableId, 'seats', String(seatIndex));
          const seatSnap = await tx.get(seatRef);
          if (!seatSnap.exists()) throw new Error('Seat missing');
          if (seatSnap.data()?.occupiedBy !== current.id) throw new Error('Not your seat');
          tx.update(seatRef, {
            occupiedBy: null,
            displayName: null,
            sittingOut: false,
            stackCents: null,
            updatedAt: serverTimestamp(),
          });
          phase = 'tableUpdate';
          tx.update(tableRef, { activeSeatCount: increment(-1) });
        });
        if (window.jamlog) {
          window.jamlog.push('seat.tx.ok', { seatIndex });
          window.jamlog.push('seat.tx.leave.stackCleared', { seatIndex });
        }
      } catch (err) {
        if (window.jamlog) {
          if (phase === 'tableUpdate') window.jamlog.push('seat.tx.fail.tableUpdate', { code: err?.code });
          else window.jamlog.push('seat.tx.fail.seatWrite', { code: err?.code });
          window.jamlog.push('seat.tx.fail', { seatIndex, code: err?.code, message: err?.message });
        }
      }
    }

    async function rulesProbe(tableId) {
      const probeRef = doc(db, `tables/${tableId}/handState/_probe`);
      try {
        await setDoc(probeRef, { updatedAt: serverTimestamp() }, { merge: true });
        if (window.jamlog) window.jamlog.push('hand.rules.probe.ok');
      } catch (e) {
        if (window.jamlog) window.jamlog.push('hand.rules.probe.fail', { code: e.code, message: e.message });
      }
    }

    function commitOf(state, seat){ return Number(state.commits?.[String(seat)] || 0); }

    function disableActionButtons(disabled) {
      ['btn-check','btn-call','btn-fold'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = disabled;
      });
    }

      function renderPlayerBoard() {
        const current = getCurrentPlayer();
        mySeatIndex = seatData.find(s => s.occupiedBy === current?.id)?.seatIndex ?? null;
        if (!current || mySeatIndex == null) { boardEl.style.display = 'none'; return; }
        const snapshotForLog = buildHandStatePayload(handState);
        const derived = deriveHandContext(snapshotForLog);
        const derivedToMatch = typeof derived.toMatch === 'number' ? derived.toMatch : null;
        const derivedMyCommit = typeof derived.myCommit === 'number' ? derived.myCommit : null;
        const toMatch = derivedToMatch ?? 0;
        const myCommit = derivedMyCommit ?? 0;
        const owe = Math.max(0, toMatch - myCommit);
        const snapshotPayload = {
          ...snapshotForLog,
          commits: { ...snapshotForLog.commits },
          myUid: current?.id || null,
          mySeat: mySeatIndex,
          toActSeat: snapshotForLog.toActSeat ?? null,
          seats: seatData.map((s, i) => ({ i, seat: toSeatNumber(s?.seatIndex ?? i), uid: s?.occupiedBy || null })),
          street: derived.street ?? snapshotForLog.street ?? null,
          handNo: derived.handNo ?? snapshotForLog.handNo ?? null,
        };
        jamlogPushThrottled('turn.snapshot', snapshotPayload, {
          toActSeat: snapshotForLog.toActSeat ?? null,
          street: derived.street ?? snapshotForLog.street ?? null,
          handNo: derived.handNo ?? snapshotForLog.handNo ?? null,
          toMatch: derivedToMatch,
          myCommit: derivedMyCommit,
        });
        boardEl.style.display = 'block';
        boardEl.innerHTML = `
          <div class="player-board__actions" style="display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
            <button id="btn-check" class="action-btn" data-action="check" type="button">Check</button>
            <button id="btn-call" class="action-btn" data-action="call" type="button">Call</button>
            <button id="btn-fold" class="action-btn" data-action="fold" type="button">Fold</button>
          </div>
          <div id="admin-action-row" class="player-board__admin" data-admin-only>
            <button id="btn-next-street" class="action-btn small" type="button">Next street</button>
          </div>
          <div style="display:flex; justify-content:center; margin-top:8px;">
            <button id="btn-leave-seat" type="button">Leave seat</button>
          </div>
        `;
        const checkBtn = document.getElementById('btn-check');
        const callBtn = document.getElementById('btn-call');
        const foldBtn = document.getElementById('btn-fold');
        const leaveBtn = document.getElementById('btn-leave-seat');
        [checkBtn, callBtn, foldBtn].forEach(b => {
          b.addEventListener('pointerdown', (e) => e.currentTarget.classList.add('pressed'));
          ['pointerup','pointercancel'].forEach(ev => b.addEventListener(ev, (e) => e.currentTarget.classList.remove('pressed')));
        });
        let reason = 'ok';
        let enable = handState && handState.street === 'preflop' && handState.toActSeat === mySeatIndex && !foldedSeats.has(mySeatIndex);
        if (!handState || handState.street !== 'preflop') { reason = 'no-hand'; enable = false; }
        else if (handState.toActSeat !== mySeatIndex || foldedSeats.has(mySeatIndex)) { reason = 'not-your-turn'; enable = false; }
        if (pending) { reason = 'pending'; enable = false; }
        const tooltip = reason === 'no-hand' ? 'Start Hand first' : 'Waiting for your turn';
        [checkBtn, callBtn, foldBtn].forEach(b => { b.disabled = !enable; if (!enable) b.title = tooltip; else b.removeAttribute('title'); });
        const guardPayload = {
          reason,
          myUid: current?.id || null,
          mySeat: mySeatIndex,
          toActSeat: snapshotForLog.toActSeat ?? null,
          toMatch,
          myCommit,
          owe,
          street: derived.street ?? snapshotForLog.street ?? null,
          handNo: derived.handNo ?? snapshotForLog.handNo ?? null,
        };
        jamlogPushThrottled('action.guard', guardPayload, {
          reason,
          toActSeat: snapshotForLog.toActSeat ?? null,
          street: derived.street ?? snapshotForLog.street ?? null,
          handNo: derived.handNo ?? snapshotForLog.handNo ?? null,
          toMatch: derivedToMatch,
          myCommit: derivedMyCommit,
        });
        leaveBtn.addEventListener('click', () => leaveSeat(mySeatIndex));
        if (enable) {
          const target = toMatch;
          checkBtn.disabled = myCommit !== target;
          callBtn.disabled = myCommit >= target;
          if (handState.street === 'preflop' && mySeatIndex === handState.bbSeat && myCommit === target) {
            checkBtn.style.fontWeight = '700';
          } else {
            checkBtn.style.fontWeight = '';
          }
          checkBtn.addEventListener('click', () => sendAction('check'));
          callBtn.addEventListener('click', () => sendAction('call'));
          foldBtn.addEventListener('click', () => sendAction('fold'));
        }
      }

    async function sendAction(type) {
      if (pending) return;
      if (window.jamlog) window.jamlog.push('ui.action.click', { type, seat: mySeatIndex });
      if (handState?.toActSeat !== mySeatIndex) {
        if (window.jamlog) window.jamlog.push('ui.action.blocked', { type, seat: mySeatIndex, reason: 'not-your-turn' });
        disableActionButtons(true);
        alert("It's not your turn");
        return;
      }
      const myCommit = commitOf(handState, mySeatIndex);
      const target = handState.betToMatchCents || 0;
      if (type === 'check' && myCommit !== target) {
        if (window.jamlog) window.jamlog.push('ui.action.blocked', { type, seat: mySeatIndex, reason: 'bet-to-match' });
        disableActionButtons(true);
        return;
      }
      if (type === 'call' && myCommit >= target) {
        if (window.jamlog) window.jamlog.push('ui.action.blocked', { type, seat: mySeatIndex, reason: 'bet-to-match' });
        disableActionButtons(true);
        return;
      }
      pending = type;
      disableActionButtons(true);
      pendingTimer = setTimeout(() => { pending = null; renderPlayerBoard(); }, 500);
      renderPlayerBoard();
      const payload = { type };
      if (type === 'call') payload.amountCents = target - myCommit;
      if (type === 'fold') foldedSeats.add(mySeatIndex);
      try {
        await enqueueAction(payload);
      } catch (e) {
        pending = null;
        if (pendingTimer) clearTimeout(pendingTimer);
        renderPlayerBoard();
      }
    }

    async function enqueueAction(action) {
      await awaitAuthReady();
      const createdByUid = auth.currentUser?.uid || 'anon';
      const actorUid = seatData[mySeatIndex]?.occupiedBy || null;
      const docRef = await addDoc(collection(db, `tables/${tableId}/actions`), {
        handNo: handState?.handNo || 0,
        seat: mySeatIndex,
        ...action,
        createdByUid,
        actorUid,
        createdAt: serverTimestamp(),
        clientTs: Date.now(),
        applied: false,
      });
      if (window.jamlog) {
        const amount = typeof action?.amountCents === 'number' && Number.isFinite(action.amountCents)
          ? action.amountCents
          : null;
        const handNo = typeof handState?.handNo === 'number' && Number.isFinite(handState.handNo)
          ? handState.handNo
          : null;
        window.jamlog.push('ui.action.enqueued', {
          id: docRef.id,
          type: action?.type || null,
          seat: mySeatIndex ?? null,
          handNo,
          amountCents: amount,
          actorUid,
        });
      }
      return docRef;
    }

    function updateDebug() {
      if (!isDebug()) { debugBox.style.display = 'none'; return; }
      debugBox.style.display = 'block';
      const pos = handData?.positions || {};
      const folded = Object.keys(handData?.folded || {}).join(',');
      debugBox.textContent = `id=${tableId}\ncurrentHandId=${tableData?.currentHandId ?? 'null'}\nnextDealerId=${tableData?.nextDealerId ?? 'null'}\nnextDealerName=${tableData?.nextDealerName ?? 'null'}\nnextVariantId=${tableData?.nextVariantId ?? 'null'}\npositions=${pos.dealerSeatNum ?? 'null'},${pos.sbSeatNum ?? 'null'},${pos.bbSeatNum ?? 'null'}\nstage=${handData?.stage ?? 'null'}\nactorSeatNum=${handData?.actorSeatNum ?? 'null'}\nlastAggressorSeatNum=${handData?.lastAggressorSeatNum ?? 'null'}\nroundStartSeatNum=${handData?.roundStartSeatNum ?? 'null'}\ntoCallCents=${handData?.toCallCents ?? 'null'}\nminRaiseCents=${handData?.minRaiseCents ?? 'null'}\ndeckIndex=${handData?.deckIndex ?? 'null'}\nboard=${JSON.stringify(handData?.board || [])}\nfolded=${folded}\nactiveSeatCount=${seatData.filter(s => s.active).length}`;
    }
  </script>
</body>
</html>

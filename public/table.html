<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Table</title>
  <link rel="stylesheet" href="/style.css" />
  <link rel="stylesheet" href="/table.css" />
</head>
<body>
  <div class="wrap">
    <nav class="nav">
      <span style="font-weight:700;">JamPoker</span>
      <a href="/lobby.html">Lobby</a>
      <span id="debug-chip" class="small" style="margin-left:auto;cursor:pointer;padding:4px 8px;border:1px solid #334155;border-radius:8px;">Debug: OFF</span>
    </nav>
    <div id="you"></div>
    <div id="error" class="card" style="display:none;"></div>
    <div id="table-info" class="card" style="margin-top:16px;"></div>
    <div id="current-hand" class="card" style="margin-top:16px;"></div>
    <div id="seats" class="card" style="margin-top:16px;"></div>
  </div>
  <div id="player-board" class="card player-board" style="display:none;position:fixed;left:50%;bottom:0;transform:translateX(-50%);min-width:260px;"></div>
  <div id="debug-box" class="dbg" style="display:none;font-family:monospace;white-space:pre;font-size:11px;margin-top:12px;"></div>
  <script src="/jamlog.js"></script>
  <script type="module" src="/firebase-init.js"></script>
  <script type="module">
    import { app } from "/firebase-init.js";
    import { db, dollars, formatCents, renderCurrentPlayerControls, isDebug, setDebug, getCurrentPlayer, formatCard, stageLabel, showSeatsDebug, debugLog } from "/common.js";
    import {
      doc, setDoc, onSnapshot, collection, query, orderBy, addDoc, serverTimestamp,
      writeBatch, runTransaction, increment, getDoc
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
    import { awaitAuthReady } from "/auth.js";

    if (window.jamlog && isDebug()) {
      window.jamlog.init({ projectId: app.options.projectId, build: window.__BUILD_SHA__ || 'dev', page: 'TABLE' });
    }

    renderCurrentPlayerControls("you");
    const debugChip = document.getElementById('debug-chip');
    debugChip.textContent = isDebug() ? 'Debug: ON' : 'Debug: OFF';
    debugChip.addEventListener('click', () => setDebug(!isDebug()));

    const params = new URLSearchParams(window.location.search);
    const tableId = params.get('id');
    document.body.classList.add('variant-v1');
    if (window.jamlog) window.jamlog.setTableId(tableId || null);
    const errorEl = document.getElementById('error');
    const infoEl = document.getElementById('table-info');
    const handEl = document.getElementById('current-hand');
    const seatsEl = document.getElementById('seats');
    const boardEl = document.getElementById('player-board');
    const debugBox = document.getElementById('debug-box');
    const seedBanner = document.createElement('div');
    seedBanner.className = 'small';
    seedBanner.textContent = 'Seeding seats…';
    seedBanner.style.display = 'none';
    seatsEl.before(seedBanner);

    let tableData = null;
    let handData = null;
    let handState = null;
    let seatData = [];
    let unsubHand = null;
    let unsubHandState = null;
    let backfillAttempted = false;
    let backfillTimer = null;
    let seatCountTimer = null;
    let seatCountDesync = false;

    if (!tableId) {
      errorEl.style.display = 'block';
      errorEl.innerHTML = '<h1>Table not found</h1><a href="/lobby.html">Back to Lobby</a>';
    } else {
      const tableRef = doc(db, 'tables', tableId);
      const handStateRef = doc(db, 'tables', tableId, 'hand', 'state');
      if (window.jamlog) window.jamlog.push('hand.state.sub.start');
      unsubHandState = onSnapshot(handStateRef, (snap) => {
        handState = snap.exists() ? snap.data() : null;
        renderSeats();
        if (window.jamlog) window.jamlog.push('hand.state.sub.ok', { handNo: handState?.handNo ?? null });
      });
      onSnapshot(tableRef, (snap) => {
        debugLog('table.tableSnapshot', snap.exists());
        if (!snap.exists() || snap.data()?.active === false) {
          errorEl.style.display = 'block';
          const msg = !snap.exists() ? 'Table not found' : 'Table archived';
          errorEl.innerHTML = `<h1>${msg}</h1><a href="/lobby.html">Back to Lobby</a>`;
          infoEl.style.display = 'none';
          handEl.style.display = 'none';
          seatsEl.style.display = 'none';
          boardEl.style.display = 'none';
          return;
        }
        infoEl.style.display = '';
        handEl.style.display = '';
        seatsEl.style.display = '';
        tableData = { id: snap.id, ...snap.data() };
        renderTableInfo();
        if (unsubHand) unsubHand();
        if (tableData.currentHandId) {
          const handRef = doc(db, 'tables', tableId, 'hands', tableData.currentHandId);
          unsubHand = onSnapshot(handRef, (hsnap) => {
            handData = hsnap.exists() ? hsnap.data() : null;
            renderHand();
            updateDebug();
          });
        } else {
          handData = null;
          renderHand();
          updateDebug();
        }
          renderPlayerBoard();
          updateDebug();
          checkSeatCount();
        });

        const seatsRef = collection(db, 'tables', tableId, 'seats');
        if (window.jamlog) window.jamlog.push('table.seats.sub.started');
        const qSeats = query(seatsRef, orderBy('seatIndex', 'asc'));
        onSnapshot(qSeats, (snap) => {
          debugLog('table.seatsSnapshot', snap.size);
          if (window.jamlog) window.jamlog.push('table.seats.sub.ok', { count: snap.size });
          seatData = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
          showSeatsDebug(tableId, snap.docs);
          renderSeats();
          renderHand();
          renderTableInfo();
          renderPlayerBoard();
          updateDebug();
          checkSeatCount();
          if (snap.size === 0 && (tableData?.maxSeats || 0) > 0) {
            if (!backfillTimer && !backfillAttempted) {
              backfillTimer = setTimeout(() => {
                backfillTimer = null;
                if (seatData.length === 0 && (tableData?.maxSeats || 0) > 0) backfillSeats();
              }, 1000);
            }
          } else if (backfillTimer) {
            clearTimeout(backfillTimer);
            backfillTimer = null;
          }
        }, (err) => {
          if (window.jamlog) window.jamlog.push('table.seats.sub.error', { code: err?.code, message: err?.message });
        });
      }

    document.addEventListener('change', (e) => {
      if (e.target.id === 'cp-select') renderPlayerBoard();
    });

    async function backfillSeats() {
      backfillAttempted = true;
      if (isDebug()) seedBanner.style.display = 'block';
      try {
        const batch = writeBatch(db);
        const max = tableData.maxSeats || 0;
        const checks = [];
        for (let i = 0; i < max; i++) {
          const sref = doc(db, 'tables', tableId, 'seats', String(i));
          checks.push(getDoc(sref).then((snap) => {
            if (!snap.exists()) {
              batch.set(sref, {
                seatIndex: i,
                occupiedBy: null,
                displayName: null,
                sittingOut: false,
                stackCents: null,
                updatedAt: serverTimestamp(),
              });
            }
          }));
        }
        await Promise.all(checks);
        await batch.commit();
        if (window.jamlog) window.jamlog.push('table.seats.backfill.ok', { count: max });
      } catch (e) {
        if (window.jamlog) window.jamlog.push('table.seats.backfill.fail', { code: e?.code });
      } finally {
        if (isDebug()) seedBanner.style.display = 'none';
      }
    }

    function checkSeatCount() {
      if (!tableData) return;
      const derived = seatData.filter(s => s.occupiedBy).length;
      const active = tableData.activeSeatCount ?? 0;
      if (derived !== active) {
        if (!seatCountTimer) {
          seatCountTimer = setTimeout(() => {
            seatCountTimer = null;
            const d = seatData.filter(s => s.occupiedBy).length;
            const a = tableData.activeSeatCount ?? 0;
            if (d !== a) {
              seatCountDesync = true;
              if (window.jamlog) window.jamlog.push('seatcount.desync', { derived: d, activeSeatCount: a });
              renderTableInfo();
            }
          }, 1000);
        }
      } else {
        if (seatCountTimer) { clearTimeout(seatCountTimer); seatCountTimer = null; }
        if (seatCountDesync) {
          seatCountDesync = false;
          renderTableInfo();
        }
      }
    }

    function renderTableInfo() {
      if (!tableData) { infoEl.textContent = ''; return; }
      const t = tableData;
      const sb = t?.blinds?.sbCents ?? t.smallBlindCents ?? 0;
      const bb = t?.blinds?.bbCents ?? t.bigBlindCents ?? 0;
      const minB = t?.buyIn?.minCents ?? t.minBuyInCents ?? 0;
      const maxB = t?.buyIn?.maxCents ?? t.maxBuyInCents ?? 0;
      const defB = t?.buyIn?.defaultCents ?? t.defaultBuyInCents ?? 0;
      const blindStr = `${dollars(sb)}/${dollars(bb)}`;
      const rangeStr = `${dollars(minB)}–${dollars(maxB)} (default ${dollars(defB)})`;
      const derivedSeatCount = seatData.filter(s => s.occupiedBy).length;
      const activeSeatCount = t.activeSeatCount ?? 0;
      const desyncLine = seatCountDesync ? `<div class="small">Players seated: ${derivedSeatCount} (active: ${activeSeatCount})</div>` : '';
      const current = getCurrentPlayer();
      const showStart = (current && seatData.some(s => s.occupiedBy === current.id)) || isDebug();
      const startBtnHtml = showStart ? `<div style="margin-top:8px;text-align:right;"><button id="btn-start-hand" class="small">Start Hand</button></div>` : '';
      infoEl.innerHTML = `
        <h1>${t.name || '(no name)'}</h1>
        <div class="small">Blinds: ${blindStr}</div>
        <div class="small">Buy-in: ${rangeStr}</div>
        <div class="small">Seats: ${derivedSeatCount} / ${t.maxSeats || 0}</div>
        ${desyncLine}
        ${startBtnHtml}
      `;
      if (showStart) {
        document.getElementById('btn-start-hand')?.addEventListener('click', startHand);
      }
    }

    function renderHand() {
      if (!handData) {
        const seatCount = seatData.filter(s => s.occupiedBy).length;
        handEl.innerHTML = seatCount < 2 ? 'Waiting for players…' : 'Waiting for next dealer’s choice…';
        renderPlayerBoard();
        return;
      }
      if (handData.status === 'ended') {
        handEl.textContent = handData.showdownPending ? 'Showdown pending — pot held' : 'Hand ended — waiting for next hand…';
        renderPlayerBoard();
        return;
      }
      const h = handData;
      const vLabel = h.variant === 'omaha' ? 'Omaha' : "Hold'em";
      const stageStr = stageLabel(h);
      const getNameBySeat = (n) => seatData.find(s => s.seatIndex === n)?.displayName || '(left)';
      const dealerName = h.dealerName || getNameBySeat(h.positions?.dealerSeatNum);
      const sbName = getNameBySeat(h.positions?.sbSeatNum);
      const bbName = getNameBySeat(h.positions?.bbSeatNum);
      const actorName = getNameBySeat(h.actorSeatNum);
      const board = (h.board || []).map(c => `<span class="card-chip">${formatCard(c)}</span>`).join(' ');
      let contrib = '';
      if (h.contributions) {
        const parts = [];
        for (const [pid, cents] of Object.entries(h.contributions)) {
          const name = seatData.find(s => s.occupiedBy === pid)?.displayName || '(left)';
          parts.push(`${name}: ${dollars(cents)}`);
        }
        if (parts.length) contrib = `<div class="small">${parts.join(', ')}</div>`;
      }
      const boardLine = (h.board && h.board.length)
        ? `<div class="small">Board: ${board}</div>`
        : '';
      const debugLine = isDebug()
        ? `<div class="small">board=${(h.board||[]).join(',')}${h.deckIndex !== undefined ? ` deckIndex=${h.deckIndex}` : ''}</div>`
        : '';
      handEl.innerHTML = `
        <div>Current Hand: ${vLabel} • Dealer: ${dealerName} • Status: ${h.status}</div>
        <div class="small" style="margin-top:4px;">Pot: ${dollars(h.potCents || 0)}</div>
        <div class="small">Stage: ${stageStr}</div>
        ${boardLine}
        <div class="small">Positions: Dealer ${dealerName}, SB ${sbName}, BB ${bbName}</div>
        ${contrib}
        <div class="small" style="margin-top:4px;">Action: ${actorName}</div>
        ${debugLine}
      `;
      renderPlayerBoard();
    }

    function renderSeats() {
      const maxSeats = tableData?.maxSeats || seatData.length || 0;
      const ring = document.createElement('div');
      ring.className = 'seat-ring';
      for (let i = 0; i < maxSeats; i++) {
        const seat = seatData.find((s) => s.seatIndex === i);
        const seatEl = document.createElement('div');
        seatEl.className = 'seat';
        seatEl.style.setProperty('--i', String(i));
        seatEl.style.setProperty('--n', String(maxSeats));
        if (seat && seat.occupiedBy) {
          const stackLabel = seat.stackCents != null ? formatCents(seat.stackCents) : '—';
          seatEl.innerHTML = `<div class="name">${seat.displayName || '(no name)'}</div><div class="stack small">${stackLabel}</div>`;
        } else {
          seatEl.innerHTML = '<div class="small">Sit here</div>';
          seatEl.addEventListener('click', () => claimSeat(i));
        }
        if (handState) {
          if (i === handState.dealerSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge dealer';
            b.textContent = 'D';
            seatEl.appendChild(b);
          }
          if (i === handState.sbSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge sb';
            b.textContent = 'SB';
            seatEl.appendChild(b);
          }
          if (i === handState.bbSeat) {
            const b = document.createElement('div');
            b.className = 'pos-badge bb';
            b.textContent = 'BB';
            seatEl.appendChild(b);
          }
        }
        ring.appendChild(seatEl);
      }
      seatsEl.innerHTML = '';
      seatsEl.appendChild(ring);
    }

    async function claimSeat(seatIndex) {
      const current = getCurrentPlayer();
      if (!current) { alert('Select a Current Player first.'); return; }
      if (window.jamlog) window.jamlog.push('seat.tx.start', { seatIndex });
      let stack = 0;
      let phase = 'seatWrite';
      try {
        await awaitAuthReady();
        await runTransaction(db, async (tx) => {
          const tableRef = doc(db, 'tables', tableId);
          const seatRef = doc(db, 'tables', tableId, 'seats', String(seatIndex));
          const [tableSnap, seatSnap] = await Promise.all([
            tx.get(tableRef),
            tx.get(seatRef),
          ]);
          if (!tableSnap.exists()) throw new Error('Table not found');
          if (seatSnap.exists() && seatSnap.data()?.occupiedBy) throw new Error('Seat taken');
          const t = tableSnap.data();
          const buy = t?.buyIn || {};
          let min = typeof buy.minCents === 'number' ? buy.minCents : 0;
          let max = typeof buy.maxCents === 'number' ? buy.maxCents : min;
          let def = typeof buy.defaultCents === 'number' ? buy.defaultCents : min;
          if (min > max) {
            if (window.jamlog) window.jamlog.push('table.buyin.invalid', { minCents: min, maxCents: max });
            const fb = Math.min(min, max);
            min = max = def = fb;
          }
          stack = Math.min(Math.max(def, min), max);
          const seatData = {
            seatIndex,
            occupiedBy: current.id,
            displayName: current.name || '',
            sittingOut: false,
            stackCents: stack,
            updatedAt: serverTimestamp(),
          };
          if (seatSnap.exists()) tx.update(seatRef, seatData);
          else tx.set(seatRef, seatData);
          phase = 'tableUpdate';
          tx.update(tableRef, { activeSeatCount: increment(1) });
        });
        if (window.jamlog) {
          window.jamlog.push('seat.tx.ok', { seatIndex });
          window.jamlog.push('seat.tx.claim.stack', { seatIndex, stackCents: stack });
        }
      } catch (err) {
        if (window.jamlog) {
          if (phase === 'tableUpdate') window.jamlog.push('seat.tx.fail.tableUpdate', { code: err?.code });
          else window.jamlog.push('seat.tx.fail.seatWrite', { code: err?.code });
          window.jamlog.push('seat.tx.fail', { seatIndex, code: err?.code, message: err?.message });
        }
        alert('Seat taken or no permission.');
      }
    }

    async function leaveSeat(seatIndex) {
      const current = getCurrentPlayer();
      if (!current) return;
      if (window.jamlog) window.jamlog.push('seat.tx.start', { seatIndex });
      let phase = 'seatWrite';
      try {
        await awaitAuthReady();
        await runTransaction(db, async (tx) => {
          const tableRef = doc(db, 'tables', tableId);
          const seatRef = doc(db, 'tables', tableId, 'seats', String(seatIndex));
          const seatSnap = await tx.get(seatRef);
          if (!seatSnap.exists()) throw new Error('Seat missing');
          if (seatSnap.data()?.occupiedBy !== current.id) throw new Error('Not your seat');
          tx.update(seatRef, {
            occupiedBy: null,
            displayName: null,
            sittingOut: false,
            stackCents: null,
            updatedAt: serverTimestamp(),
          });
          phase = 'tableUpdate';
          tx.update(tableRef, { activeSeatCount: increment(-1) });
        });
        if (window.jamlog) {
          window.jamlog.push('seat.tx.ok', { seatIndex });
          window.jamlog.push('seat.tx.leave.stackCleared', { seatIndex });
        }
      } catch (err) {
        if (window.jamlog) {
          if (phase === 'tableUpdate') window.jamlog.push('seat.tx.fail.tableUpdate', { code: err?.code });
          else window.jamlog.push('seat.tx.fail.seatWrite', { code: err?.code });
          window.jamlog.push('seat.tx.fail', { seatIndex, code: err?.code, message: err?.message });
        }
      }
    }

    async function startHand() {
      if (window.jamlog) window.jamlog.push('hand.start.click');
      const occupied = seatData.filter(s => s.occupiedBy).map(s => s.seatIndex).sort((a,b) => a - b);
      const stateRef = doc(db, 'tables', tableId, 'hand', 'state');
      try {
        await awaitAuthReady();
        let currentState = handState;
        if (!currentState) {
          const snap = await getDoc(stateRef);
          currentState = snap.exists() ? snap.data() : null;
        }
        if (occupied.length < 2) {
          const handNo = typeof currentState?.handNo === 'number' ? currentState.handNo : 0;
          await setDoc(stateRef, { handNo, dealerSeat: null, sbSeat: null, bbSeat: null, toActSeat: null, updatedAt: serverTimestamp() }, { merge: true });
          if (window.jamlog) window.jamlog.push('hand.start.fail', { code: 'not-enough-players', message: 'Need 2+ players' });
          alert('Need 2+ players');
          return;
        }
        const next = (arr, val) => arr[(arr.indexOf(val) + 1) % arr.length];
        let dealer;
        if (currentState && occupied.includes(currentState.dealerSeat)) {
          dealer = next(occupied, currentState.dealerSeat);
        } else {
          dealer = occupied[0];
        }
        const sb = next(occupied, dealer);
        const bb = next(occupied, sb);
        const toAct = next(occupied, bb);
        const handNo = (typeof currentState?.handNo === 'number' ? currentState.handNo : 0) + 1;
        await setDoc(stateRef, { handNo, dealerSeat: dealer, sbSeat: sb, bbSeat: bb, toActSeat: toAct, updatedAt: serverTimestamp() }, { merge: true });
        if (window.jamlog) window.jamlog.push('hand.start.ok', { handNo, dealerSeat: dealer, sbSeat: sb, bbSeat: bb, toActSeat: toAct });
      } catch (err) {
        if (window.jamlog) window.jamlog.push('hand.start.fail', { code: err?.code, message: err?.message });
        alert('Error starting hand.');
      }
    }

    let intentPending = false;
    async function renderPlayerBoard() {
      const current = getCurrentPlayer();
      if (!current) { boardEl.style.display = 'none'; return; }
      const seat = seatData.find(s => s.occupiedBy === current.id);
      boardEl.style.display = 'block';
      if (!seat) {
        boardEl.innerHTML = '<div class="small" style="text-align:center;">Not seated — pick a seat to play</div>';
        return;
      }
      const folded = handData?.folded || {};
      const isActor = handData && seat.seatIndex === handData.actorSeatNum && !folded[current.id] && (seat.stackCents > 0);
      const toCall = handData?.toCallCents || 0;
      const minRaise = handData?.minRaiseCents || 0;
      const callLabel = toCall > 0 ? `Call ${dollars(toCall)}` : 'Check';
      const raiseLabel = `Min-Raise ${dollars(minRaise)}`;
      const actionsHtml = isActor ? `
        <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:8px;">
          <button id="btn-fold">Fold</button>
          <button id="btn-call">${callLabel}</button>
          <button id="btn-raise">${raiseLabel}</button>
        </div>
      ` : '<div class="small" style="text-align:center;margin-top:8px;">Waiting…</div>';
      const stackLine = `<div class="small" style="text-align:center;">Stack: ${formatCents(seat.stackCents || 0)}</div>`;
      boardEl.innerHTML = `
        ${stackLine}
        <div style="display:flex; justify-content:center; gap:8px;">
          <span class="card-chip">[ ?? ]</span>
          <span class="card-chip">[ ?? ]</span>
        </div>
        ${actionsHtml}
        <div style="display:flex; justify-content:center; margin-top:8px;">
          <button id="btn-leave-seat">Leave seat</button>
        </div>
      `;
      const leaveBtn = document.getElementById('btn-leave-seat');
      leaveBtn.addEventListener('click', () => leaveSeat(seat.seatIndex));
      if (isActor) {
        const foldBtn = document.getElementById('btn-fold');
        const callBtn = document.getElementById('btn-call');
        const raiseBtn = document.getElementById('btn-raise');
        const disable = (d) => { foldBtn.disabled = callBtn.disabled = raiseBtn.disabled = d; };
        const intentsCol = collection(db, 'tables', tableId, 'hands', tableData.currentHandId, 'intents');
        const send = async (data) => {
          if (intentPending) return;
          intentPending = true;
          disable(true);
          try {
            await awaitAuthReady();
            await addDoc(intentsCol, { ...data, createdAt: serverTimestamp() });
          } catch (e) {
            console.error(e);
          }
          intentPending = false;
          disable(false);
        };
        foldBtn.addEventListener('click', () => send({ playerId: current.id, type: 'fold' }));
        callBtn.addEventListener('click', () => send({ playerId: current.id, type: toCall > 0 ? 'call' : 'check' }));
        raiseBtn.addEventListener('click', () => send({ playerId: current.id, type: 'raise', amountCents: minRaise }));
      }
    }

    function updateDebug() {
      if (!isDebug()) { debugBox.style.display = 'none'; return; }
      debugBox.style.display = 'block';
      const pos = handData?.positions || {};
      const folded = Object.keys(handData?.folded || {}).join(',');
      debugBox.textContent = `id=${tableId}\ncurrentHandId=${tableData?.currentHandId ?? 'null'}\nnextDealerId=${tableData?.nextDealerId ?? 'null'}\nnextDealerName=${tableData?.nextDealerName ?? 'null'}\nnextVariantId=${tableData?.nextVariantId ?? 'null'}\npositions=${pos.dealerSeatNum ?? 'null'},${pos.sbSeatNum ?? 'null'},${pos.bbSeatNum ?? 'null'}\nstage=${handData?.stage ?? 'null'}\nactorSeatNum=${handData?.actorSeatNum ?? 'null'}\nlastAggressorSeatNum=${handData?.lastAggressorSeatNum ?? 'null'}\nroundStartSeatNum=${handData?.roundStartSeatNum ?? 'null'}\ntoCallCents=${handData?.toCallCents ?? 'null'}\nminRaiseCents=${handData?.minRaiseCents ?? 'null'}\ndeckIndex=${handData?.deckIndex ?? 'null'}\nboard=${JSON.stringify(handData?.board || [])}\nfolded=${folded}\nactiveSeatCount=${seatData.filter(s => s.active).length}`;
    }
  </script>
</body>
</html>

name: deploy-on-merge

on:
  push:
    branches: [ main ]

concurrency:
  group: deploy-main
  cancel-in-progress: true

env:
  PROJECT_ID: jam-poker

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install deps (root)
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Install Firebase CLI
        run: npm install -g firebase-tools

      - name: Install deps (functions)
        run: |
          set -e
          cd functions
          if [ -f package-lock.json ]; then
            npm ci --no-audit --no-fund
          else
            npm install --no-audit --no-fund
          fi

      - name: Build Cloud Functions
        run: |
          set -e
          cd functions
          npm run build || echo "No build script; skipping"

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.FIREBASE_SERVICE_ACCOUNT_JAM_POKER }}

      - name: Deploy Functions and Hosting to production
        run: firebase deploy --only functions,hosting --project "$PROJECT_ID" --non-interactive --force --json | tee deploy.log

      - name: Summarize Cloud Functions deployment
        shell: bash
        run: |
          node <<'NODE'
          const fs = require('fs');
          const logPath = 'deploy.log';
          if (!fs.existsSync(logPath)) {
            console.log('deploy.log not found.');
            process.exit(0);
          }

          const lines = fs.readFileSync(logPath, 'utf8').trim().split(/\r?\n/).reverse();
          const jsonLine = lines.find((line) => {
            const trimmed = line.trim();
            return trimmed.startsWith('{') && trimmed.endsWith('}');
          });

          if (!jsonLine) {
            console.log('No JSON output found in deploy.log.');
            process.exit(0);
          }

          let payload;
          try {
            payload = JSON.parse(jsonLine);
          } catch (error) {
            console.error('Failed to parse deploy.log JSON output.');
            console.error(error);
            process.exit(1);
          }

          const operations = [];
          const collect = (value) => {
            if (!value) {
              return;
            }
            if (Array.isArray(value)) {
              value.forEach(collect);
              return;
            }
            if (typeof value === 'object') {
              const hasOperation =
                typeof value.operationType === 'string' || typeof value.type === 'string';
              const hasName = ['id', 'functionName', 'name', 'resource'].some(
                (key) => typeof value[key] === 'string' && value[key]
              );
              if (hasOperation && hasName) {
                operations.push(value);
              }
              Object.values(value).forEach(collect);
            }
          };

          collect(payload);

          const buckets = {
            added: [],
            updated: [],
            deleted: [],
          };

          const extractName = (entry) => {
            if (typeof entry.id === 'string' && entry.id) {
              return entry.id;
            }
            const candidateKey = ['functionName', 'name', 'resource'].find(
              (key) => typeof entry[key] === 'string' && entry[key]
            );
            if (candidateKey) {
              const parts = entry[candidateKey].split('/');
              return parts[parts.length - 1] || entry[candidateKey];
            }
            return 'unknown';
          };

          const mapOperation = (value) => {
            const raw = String(value || '').toLowerCase();
            if (raw.includes('create') || raw.includes('add')) {
              return 'added';
            }
            if (raw.includes('delete') || raw.includes('remove')) {
              return 'deleted';
            }
            return 'updated';
          };

          operations.forEach((entry) => {
            const type = entry.operationType ?? entry.type;
            const bucket = mapOperation(type);
            buckets[bucket].push(extractName(entry));
          });

          const format = (items) => (items.length ? items.join(', ') : 'none');
          console.log(`Functions added: ${format(buckets.added)}`);
          console.log(`Functions updated: ${format(buckets.updated)}`);
          console.log(`Functions deleted: ${format(buckets.deleted)}`);
          NODE
